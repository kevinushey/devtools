#' @section \code{use_cmake}:
#' Adds a \code{CMakeLists.txt} file to the project and generates a build directory
#' (at \code{<pkg>-build}), which IDEs can use to open and provide code navigation
#' and completion.
#' @export
#' @name infrastructure
#' @rdname infrastructure
use_cmake <- function(pkg = ".") {
  pkg <- as.package(pkg)

  cmakelists_path <- file.path(pkg$path, "CMakeLists.txt")
  if (interactive() && file.exists(cmakelists_path)) {
    response <- readline("A 'CMakeLists.txt' file already exists! Overwrite? [Y/n]: ")
    if (tolower(substring(response, 1, 1)) != "y") {
      message("Aborted from 'use_cmake()'.")
      return(invisible(NULL))
    }
  }

  NAME <- toupper(pkg$package)

  source_globs <- c(
    "src/*.cpp",
    "src/*.c"
  )

  header_globs <- c(
    "src/*.hpp",
    "src/*.h",
    "inst/include/*.hpp",
    "inst/include/*.h"
  )

  generic_directives <- unlist(c(
    cmake_minimum_required("3.0"),
    cmake_project("roxygen2"),

    cmake_file_glob_recurse(
      paste0(NAME, "_SOURCES"),
      source_globs
    ),

    cmake_file_glob_recurse(
      paste0(NAME, "_HEADERS"),
      header_globs
    ),

    "## Used for an 'all' target so IDEs will index _all_ files in a project",
    "## even if they aren't actually used for the package build",
    cmake_file_glob_recurse(
      "ALL_FILES",
      "*"
    ),

    lapply(c("R", "man", "tests", "vignettes", "inst"), function(x) {
      cmake_file_glob_recurse(
        paste0(NAME, "_", toupper(x)),
        paste0(x, "/*")
      )
    }),

    cmake_add_definitions("-DNDEBUG"),

    cmake_add_library(pkg$package,
      sapply(c("sources", "headers"), function(x) as_cmake_env(x, pkg = pkg))
    ),

    cmake_add_library(exclude_from_all = TRUE,
      paste0(pkg$package, "-all"),
      "${ALL_FILES}"
    ),

    cmake_add_custom_target(
      name = "pkg",
      command = "R CMD INSTALL --preclean ${CMAKE_BINARY_DIR}/..",
      dir = "$ENV{TMPDIR}"
    )
  ))

  platform_directives <- list(
    Windows = use_cmake_windows(pkg = pkg),
    Mac = use_cmake_mac(pkg = pkg),
    Linux = use_cmake_linux(pkg = pkg)
  )

  output <- c(
    "## CMakeLists.txt automatically generated by devtools::use_cmake()",
    generic_directives,
    "",
    cmake_if("UNIX", platform_directives$Linux),
    "",
    cmake_if("WIN32", platform_directives$Windows),
    "",
    cmake_if("APPLE", platform_directives$Mac)
  )

  cat(output, file = file.path(pkg$path, "CMakeLists.txt"), sep = "\n")

  use_build_ignore("CMakeLists.txt", pkg = pkg)
  message("> 'CMakeLists.txt' file successfully generated.")
}

run_cmake <- function(args = NULL, build_dir, pkg = ".") {
  pkg <- as.package(pkg)

  cmake <- Sys.which("cmake")
  if (cmake == "") {
    stop("'cmake' executable could not be found")
  }

  build_path <- file.path(
    pkg$path,
    build_dir
  )

#   if (dir.exists(build_path)) {
#     stop("Path '", build_path, "' already exists!")
#   }

  dir.create(build_path, showWarnings = FALSE)
  with_dir(build_path, {
    if (!is.null(args)) {
      cmd <- paste("cmake", "..", paste(args, collapse = " "))
    } else {
      cmd <- "cmake .."
    }
    message("> Running '", cmd, "' to generate project files...")
    result <- suppressWarnings(
      system2("cmake", c("..", args, "-Wno-dev"),
              stdout = TRUE, stderr = TRUE)
    )
  })

  use_build_ignore(build_dir, pkg = pkg)
  use_git_ignore(build_dir, pkg = pkg)
  message("> Done!")
}

#' @section \code{use_ide}:
#' Allows an \R package containing C/C++ source files to be managed from within
#' a generic cmake-compatible IDE, e.g. QtCreator.
#' @export
#' @name infrastructure
#' @rdname infrastructure
use_ide <- function(pkg = ".") {
  pkg <- as.package(pkg)
  use_cmake(pkg = pkg)
  build_dir <- paste(pkg$package, "build", sep = "-")
  run_cmake(build_dir = build_dir, pkg = pkg)
}

#' @section \code{use_xcode}:
#' Allows an \R package containing C/C++ source files to be managed from within
#' the XCode IDE.
#' @export
#' @name infrastructure
#' @rdname infrastructure
use_xcode <- function(pkg = ".") {
  pkg <- as.package(pkg)
  use_cmake(pkg = pkg)

  build_dir <- paste(pkg$package, "xcode", "build", sep = "-")
  run_cmake(args = "-GXcode", build_dir = build_dir, pkg = pkg)

  open <- paste("open", file.path(build_dir, paste0(pkg$package, ".xcodeproj")))

  if (is.mac()) {
    msg <- c(
      "> XCode project files successfully generated.\n\n",
      "Open the project in XCode with:\n\n    ",
      open,
      "\n\nor by manually opening the project from within XCode."
    )

    message(msg)
  }

  invisible(open)

}

with_dir <- function(dir, expr) {
  owd <- getwd()
  on.exit(setwd(owd))
  setwd(dir)
  force(expr)
}

cmake_if <- function(platform, code) {
  c(
    paste0("if (", platform, ")"),
    paste0("  ", gsub("\n", "\n  ", code)),
    "endif()"
  )
}

make_directives <- function(list, collapse = FALSE) {
  output <- character(length(list))
  for (i in seq_along(list)) {
    output[[i]] <- paste0(
      names(list)[[i]],
      if (collapse) "(" else "(\n  ",
      paste(list[[i]], collapse = if (collapse) " " else "\n  "),
      if (collapse) ")\n" else "\n)\n"
    )
  }
  output
}

make_file_directive <- function(manipulation, variable, exprs) {
  paste0(
    "file(",
    manipulation, " ",
    variable, "\n  ",
    paste(exprs, collapse = "\n  "),
    "\n)"
  )
}

make_library_directive <- function(name, link, vec) {
  paste0(
    "add_library(",
    name, " ",
    link, "\n  ",
    paste(vec, collapse = "\n  "),
    "\n)\n"
  )
}

make_exe_directive <- function(name, vec) {
  paste0(
    "add_executable(",
    name, "\n  ",
    paste(vec, collapse = "\n  "),
    "\n)\n"
  )
}

add_custom_target <- function(target, command, dir) {
  paste0(
    "add_custom_target(", target,
    "\n  ", "COMMAND ", command,
    "\n  ", "WORKING_DIRECTORY ", dir,
    "\n)"
  )
}

make_set_directives <- function(list) {
  output <- character(length(list))
  for (i in seq_along(list)) {
    output[[i]] <- paste0(
      "set(",
      names(list)[[i]],
      "\n  ",
      paste(list[[i]], collapse = "\n  "),
      "\n)\n"
    )
  }
  output
}

base_cmake_directives <- function(pkg) {
  list(
    cmake_minimum_required = "VERSION 2.8 FATAL_ERROR",
    project = pkg$package
  )
}

package.file <- function(..., package, mustWork = TRUE) {
  result <- setNames(vapply(package, FUN.VALUE = character(1), function(pkg) {
    system.file(..., package = pkg, mustWork = mustWork)
  }), package)
  result[result != ""]
}

use_cmake_linux <- function(pkg) {
  ## TODO
}

use_cmake_windows <- function(pkg) {
  ## TODO
}

use_cmake_mac <- function(pkg) {

  include_directories <- c(
    R.home("include"),
    unname(package.file("include", package = pkg_linking_to(pkg))),
    "inst/include",
    "/usr/local/include",
    "/usr/include"
  )

  link_directories <- c(
    R.home("lib"),
    unname(package.file("lib", package = pkg_linking_to(pkg), mustWork = FALSE))
  )

  link_libraries <- c(
    "libR.dylib"
  )

  add_compile_options <- c(
    "-fPIC",
    "-g",
    "-O3",
    "-Wall"
  )

  CMAKE_EXE_LINKER_FLAGS <- c(
    "-dynamiclib",
    "-Wl,-headerpad_max_install_names",
    "-undefined dynamic_lookup",
    "-single_module",
    "-multiply_defined suppress",
    "-Wl,CoreFoundation"
  )

  pkgname_upper <- toupper(pkg$package)

  all <- c(
    "## Main directives -- thes may need to be updated manually if",
    "## you are making use of libraries not declared in the DESCRIPTION",
    cmake_include_directories(include_directories),
    cmake_target_link_libraries(
      target = pkg$package,
      file.path(R.home("lib"), "libR.dylib")
    ),
    cmake_add_compile_options(add_compile_options),
    cmake_set("CMAKE_EXE_LINKER_FLAGS", CMAKE_EXE_LINKER_FLAGS)
  )

}

as_cmake_env <- function(name, pkg) {
  paste0("${", toupper(pkg$package), "_", toupper(name), "}")
}
